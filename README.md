This is the link to my github repository: https://github.com/biancapistea/webApi

**The application - Step 1**
=============================

### Prerequisites: ###
1. **You need to have .NET installed on your machine. On macOs, you can install it from here https://learn.microsoft.com/en-us/dotnet/core/install/macos**
2. **You need to install an IDE, I used Visual Studio Code. You can get it from here: https://code.visualstudio.com/download**

I created a GitHub Action worflow for continous integration CI:

In your Github, fork my repository: https://github.com/biancapistea/webApi.git or put the .zip file on a github repository.

Make a change in the code to see that the pipeline is working (codeql pipeline) which contains 2 steps: first, it verifies the code (linting) and then build the app

**The custom image - Step 2**
=============================
**Packer allows you to chain images together, similar to Docker layers. (How does it differ?)**

Packer and Docker both provide methods for creating machine images, but they have some key differences in how they handle image layering.
- In Docker, images are built using a union file system, where each layer represents a change to the filesystem.When you build a Docker image, each instruction in the Dockerfile creates a new layer on top of the previous layers. This approach allows for efficient sharing of common layers and incremental updates.
- Packer, on the other hand, doesn't inherently use layers in the same way Docker does. Instead, Packer focuses on building images from a base configuration and applying provisioning steps to that base. While it supports creating images in multiple stages, it doesn't emphasize the layering concept as prominently as Docker does.

### Prerequisites: ###

1. **Make sure that you have packer installed, if you are on a macOs/linux you can install using brew install packer**
2. **You can verify that is installed by writing packer in your terminal.**
3. **Make sure that you have an AWS account**
    1. Go to the AWS website (https://aws.amazon.com/).
    2. Click on the "Create an AWS Account" button.
    3. Follow the on-screen instructions to create your AWS account. You will need to provide your email address, create a password, and enter some personal information.
    4. Provide Payment Information
    5. Access Your AWS Management Console - Once your account is set up and verified, log in to the AWS Management Console using your newly created credentials.
    6. Generate Access Key ID and Secret Access Key
    7. In the AWS Management Console, navigate to the IAM (Identity and Access Management) service.
    8. Click on "Users" in the left navigation pane and then click on "Add user."
    9. Enter a username for the new user and select "Programmatic access" as the access type.
    10. Proceed to the permissions step and attach policies that grant the necessary permissions to the user. For example, you can attach the "AdministratorAccess" policy for full administrative access, or you can create custom policies.
    11. Review the user details and create the user - Once created, you will see the Access Key ID and Secret Access Key. Be sure to copy these credentials as they are only displayed once. If you lose them, you will need to generate a new pair.
    12. Use AWS Credentials in your applications


### There are 2 files for building images: ####

**windows.json.pkr.hcl** -> This Packer template is used to create a custom Amazon Machine Image (AMI) on AWS using the Amazon Elastic Block Store (EBS) service. It installs the prerequisites needed for the Windows Virtual Machine Image to run the .NET application created. 

If you want to run it locally, on your machine, you first need to export the variables needed:
```
export AWS_SECRET_ACCESS_KEY=“INSERT HERE YOUR AWS_SECRET_ACCESS_KEY from aws” 
export AWS_ACCESS_KEY="INSERT HERE YOUR AWS_ACCESS_KEY from aws” 
export AWS_REGION=“INSERT HERE YOUR REGION from aws”
``` 
Then, you can run it using: `packer build windows.json.pkr.hcl`

**The following will appear, if it’s successful:**
```
amazon-ebs.autogenerated_1: output will be in this color.

==> amazon-ebs.autogenerated_1: Prevalidating any provided VPC information
==> amazon-ebs.autogenerated_1: Prevalidating AMI Name: packer prerequisites 20240417131326
    amazon-ebs.autogenerated_1: Found Image ID: ami-0381840963c35cb1f
==> amazon-ebs.autogenerated_1: Creating temporary keypair: packer_661fcaf6-10da-5e84-d5da-966e4793050d
==> amazon-ebs.autogenerated_1: Creating temporary security group for this instance: packer_661fcaf7-e2f8-e48c-d1ad-95be947d089d
==> amazon-ebs.autogenerated_1: Authorizing access to port 5985 from [0.0.0.0/0] in the temporary security groups...
==> amazon-ebs.autogenerated_1: Launching a source AWS instance...
    amazon-ebs.autogenerated_1: Instance ID: i-0c82da0f924d1b675
==> amazon-ebs.autogenerated_1: Waiting for instance (i-0c82da0f924d1b675) to become ready...
==> amazon-ebs.autogenerated_1: Skipping waiting for password since WinRM password set...
==> amazon-ebs.autogenerated_1: Using WinRM communicator to connect: 3.70.95.151
==> amazon-ebs.autogenerated_1: Waiting for WinRM to become available...
    amazon-ebs.autogenerated_1: WinRM connected.
==> amazon-ebs.autogenerated_1: Connected to WinRM!
==> amazon-ebs.autogenerated_1: Provisioning with Powershell...
==> amazon-ebs.autogenerated_1: Provisioning with powershell script: ./prerequisites.ps1
    amazon-ebs.autogenerated_1: dotnet-install: Downloaded file https://dotnetcli.azureedge.net/dotnet/aspnetcore/Runtime/8.0.4/aspnetcore-runtime-8.0.4-win-x64.zip size is 45277777 bytes.
    amazon-ebs.autogenerated_1: dotnet-install: Either downloaded or local package size can not be measured. One of them may be corrupted.
    amazon-ebs.autogenerated_1: dotnet-install: Extracting the archive.
    amazon-ebs.autogenerated_1: dotnet-install: Adding to current process PATH: "C:\Users\Administrator\AppData\Local\Microsoft\dotnet\". Note: This change will not be visible if PowerShell was run as a child process.
    amazon-ebs.autogenerated_1: dotnet-install: Note that the script does not resolve dependencies during installation.
    amazon-ebs.autogenerated_1: dotnet-install: To check the list of dependencies, go to https://learn.microsoft.com/dotnet/core/install/windows#dependencies
    amazon-ebs.autogenerated_1: dotnet-install: Installed version is 8.0.4
    amazon-ebs.autogenerated_1: dotnet-install: Installation finished
    amazon-ebs.autogenerated_1: dotnet-install: Downloaded file https://dotnetcli.azureedge.net/dotnet/Sdk/8.0.204/dotnet-sdk-8.0.204-win-x64.zip size is 294676060 bytes.
    amazon-ebs.autogenerated_1: dotnet-install: Either downloaded or local package size can not be measured. One of them may be corrupted.
    amazon-ebs.autogenerated_1: dotnet-install: Extracting the archive.
    amazon-ebs.autogenerated_1: dotnet-install: Note that the script does not resolve dependencies during installation.
    amazon-ebs.autogenerated_1: dotnet-install: To check the list of dependencies, go to https://learn.microsoft.com/dotnet/core/install/windows#dependencies
    amazon-ebs.autogenerated_1: dotnet-install: Installed version is 8.0.204
    amazon-ebs.autogenerated_1: dotnet-install: Installation finished
    amazon-ebs.autogenerated_1: 4.8.03761
    amazon-ebs.autogenerated_1:
    amazon-ebs.autogenerated_1: Success Restart Needed Exit Code      Feature Result
    amazon-ebs.autogenerated_1: ------- -------------- ---------      --------------
    amazon-ebs.autogenerated_1: True    No             Success        {Common HTTP Features, Default Document, D...
    amazon-ebs.autogenerated_1: True    No             Success        {ASP.NET 4.7, Management Service}
==> amazon-ebs.autogenerated_1: Stopping the source instance...
    amazon-ebs.autogenerated_1: Stopping instance
==> amazon-ebs.autogenerated_1: Waiting for the instance to stop...
==> amazon-ebs.autogenerated_1: Creating AMI packer prerequisites 20240417131326 from instance i-0c82da0f924d1b675
    amazon-ebs.autogenerated_1: AMI: ami-095275493b7887845
==> amazon-ebs.autogenerated_1: Waiting for AMI to become ready...
==> amazon-ebs.autogenerated_1: Skipping Enable AMI deprecation...
==> amazon-ebs.autogenerated_1: Terminating the source AWS instance...
==> amazon-ebs.autogenerated_1: Cleaning up any extra volumes...
==> amazon-ebs.autogenerated_1: No volumes to clean up, skipping
==> amazon-ebs.autogenerated_1: Deleting temporary security group...
==> amazon-ebs.autogenerated_1: Deleting temporary keypair...
==> amazon-ebs.autogenerated_1: Running post-processor:  (type manifest)
Build 'amazon-ebs.autogenerated_1' finished after 20 minutes 34 seconds.
```

Then, you can enter to your AWS account, on EC2, you can see your instance running and your images created by the instance:
<img width="1512" alt="Screenshot 2024-04-17 at 18 30 51" src="https://github.com/biancapistea/webApi/assets/56589178/e81f0cc7-dd92-492c-879d-c32d67f72e7b">


**windows-app.json.pkr.hcl** -> This Packer template is used to create another Amazon Machine Image (AMI) on AWS, specifically for installing the .NET application on Windows Server Image created by the packer using **windows.json.pkr.hcl**.

If you want to run it **locally**, on your machine, you will not need to export again the variables, but you need the prerequisites_ami which is the AMI ID of the previous created image (the prerequisites image). 

In order to find the AMI ID, you first need to install, if you are on a macOS: brew install jq

Then, you need to use this command: `packer build -var "prerequisites_ami=$(jq -r '.builds[-1].artifact_id' prerequisites_ami.json | cut -d ':' -f2)" windows-app.json.pkr.hcl` 

This command will search in **prerequisites_ami.json** the last created build, based on artifact_id from which it splits the string and takes the second argument which is the AMI ID.

**prerequisites_ami.json** -> it's a file that is generated by the post-processor in **windows.json.pkr.hcl**.:  
```
post-processor "manifest" {
    output = "prerequisites_ami.json"
    strip_path = true
  }
```

**The following logs will appear, if it’s successful:**
```
amazon-ebs.autogenerated_1: output will be in this color.

==> amazon-ebs.autogenerated_1: Prevalidating any provided VPC information
==> amazon-ebs.autogenerated_1: Prevalidating AMI Name: packer application 20240417134040
    amazon-ebs.autogenerated_1: Found Image ID: ami-095275493b7887845
==> amazon-ebs.autogenerated_1: Creating temporary keypair: packer_661fd158-358f-c6bb-0ec8-e6f1f7a06f7f
==> amazon-ebs.autogenerated_1: Creating temporary security group for this instance: packer_661fd159-8659-a2ac-fcec-bb142b6cd067
==> amazon-ebs.autogenerated_1: Authorizing access to port 5985 from [0.0.0.0/0] in the temporary security groups...
==> amazon-ebs.autogenerated_1: Launching a source AWS instance...
    amazon-ebs.autogenerated_1: Instance ID: i-032808045515c0df3
==> amazon-ebs.autogenerated_1: Waiting for instance (i-032808045515c0df3) to become ready...
==> amazon-ebs.autogenerated_1: Skipping waiting for password since WinRM password set...
==> amazon-ebs.autogenerated_1: Using WinRM communicator to connect: 3.76.105.57
==> amazon-ebs.autogenerated_1: Waiting for WinRM to become available...
    amazon-ebs.autogenerated_1: WinRM connected.
==> amazon-ebs.autogenerated_1: Connected to WinRM!
==> amazon-ebs.autogenerated_1: Provisioning with Powershell...
==> amazon-ebs.autogenerated_1: Provisioning with powershell script: ./application.ps1
    amazon-ebs.autogenerated_1:
    amazon-ebs.autogenerated_1:
    amazon-ebs.autogenerated_1:     Directory: C:\
    amazon-ebs.autogenerated_1:
    amazon-ebs.autogenerated_1:
    amazon-ebs.autogenerated_1: Mode                LastWriteTime         Length Name
    amazon-ebs.autogenerated_1: ----                -------------         ------ ----
    amazon-ebs.autogenerated_1: d-----        4/17/2024   1:42 PM                DotNetApp
==> amazon-ebs.autogenerated_1: Cloning into 'C:\DotNetApp'...
    amazon-ebs.autogenerated_1:
    amazon-ebs.autogenerated_1: Welcome to .NET 8.0!
    amazon-ebs.autogenerated_1: ---------------------
    amazon-ebs.autogenerated_1: SDK Version: 8.0.204
    amazon-ebs.autogenerated_1:
    amazon-ebs.autogenerated_1: Telemetry
    amazon-ebs.autogenerated_1: ---------
    amazon-ebs.autogenerated_1: The .NET tools collect usage data in order to help us improve your experience. It is collected by Microsoft and shared with the community. You can opt-out of telemetry by setting the DOTNET_CLI_TELEMETRY_OPTOUT environment variable to '1' or 'true' using your favorite shell.
    amazon-ebs.autogenerated_1:
    amazon-ebs.autogenerated_1: Read more about .NET CLI Tools telemetry: https://aka.ms/dotnet-cli-telemetry
    amazon-ebs.autogenerated_1:
    amazon-ebs.autogenerated_1: ----------------
    amazon-ebs.autogenerated_1: Installed an ASP.NET Core HTTPS development certificate.
    amazon-ebs.autogenerated_1: To trust the certificate, run 'dotnet dev-certs https --trust'
    amazon-ebs.autogenerated_1: Learn about HTTPS: https://aka.ms/dotnet-https
    amazon-ebs.autogenerated_1:
    amazon-ebs.autogenerated_1: ----------------
    amazon-ebs.autogenerated_1: Write your first app: https://aka.ms/dotnet-hello-world
    amazon-ebs.autogenerated_1: Find out what's new: https://aka.ms/dotnet-whats-new
    amazon-ebs.autogenerated_1: Explore documentation: https://aka.ms/dotnet-docs
    amazon-ebs.autogenerated_1: Report issues and find source on GitHub: https://github.com/dotnet/core
    amazon-ebs.autogenerated_1: Use 'dotnet --help' to see available commands or visit: https://aka.ms/dotnet-cli
    amazon-ebs.autogenerated_1: --------------------------------------------------------------------------------------
    amazon-ebs.autogenerated_1: MSBuild version 17.9.8+b34f75857 for .NET
    amazon-ebs.autogenerated_1:   Determining projects to restore...
    amazon-ebs.autogenerated_1:   Restored C:\DotNetApp\webApi.csproj (in 165 ms).
    amazon-ebs.autogenerated_1: C:\DotNetApp\Program.cs(3,5): warning CS0219: The variable 'x' is assigned but its value is never used [C:\DotNetApp\webApi.csproj]
    amazon-ebs.autogenerated_1: C:\DotNetApp\Program.cs(4,5): warning CS0219: The variable 'ys' is assigned but its value is never used [C:\DotNetApp\webApi.csproj]
    amazon-ebs.autogenerated_1: C:\DotNetApp\Program.cs(5,5): warning CS0219: The variable 'fd' is assigned but its value is never used [C:\DotNetApp\webApi.csproj]
    amazon-ebs.autogenerated_1: C:\DotNetApp\Program.cs(6,5): warning CS0219: The variable 'd' is assigned but its value is never used [C:\DotNetApp\webApi.csproj]
    amazon-ebs.autogenerated_1:   webApi -> C:\DotNetApp\bin\Debug\net8.0\webApi.dll
    amazon-ebs.autogenerated_1:
    amazon-ebs.autogenerated_1: Build succeeded.
    amazon-ebs.autogenerated_1:
    amazon-ebs.autogenerated_1: C:\DotNetApp\Program.cs(3,5): warning CS0219: The variable 'x' is assigned but its value is never used [C:\DotNetApp\webApi.csproj]
    amazon-ebs.autogenerated_1: C:\DotNetApp\Program.cs(4,5): warning CS0219: The variable 'ys' is assigned but its value is never used [C:\DotNetApp\webApi.csproj]
    amazon-ebs.autogenerated_1: C:\DotNetApp\Program.cs(5,5): warning CS0219: The variable 'fd' is assigned but its value is never used [C:\DotNetApp\webApi.csproj]
    amazon-ebs.autogenerated_1: C:\DotNetApp\Program.cs(6,5): warning CS0219: The variable 'd' is assigned but its value is never used [C:\DotNetApp\webApi.csproj]
    amazon-ebs.autogenerated_1:     4 Warning(s)
    amazon-ebs.autogenerated_1:     0 Error(s)
    amazon-ebs.autogenerated_1:
    amazon-ebs.autogenerated_1: Time Elapsed 00:01:03.42
==> amazon-ebs.autogenerated_1: Stopping the source instance...
    amazon-ebs.autogenerated_1: Stopping instance
==> amazon-ebs.autogenerated_1: Waiting for the instance to stop...
==> amazon-ebs.autogenerated_1: Creating AMI packer application 20240417134040 from instance i-032808045515c0df3
    amazon-ebs.autogenerated_1: AMI: ami-0dd63d67cdb75ab06
==> amazon-ebs.autogenerated_1: Waiting for AMI to become ready...
==> amazon-ebs.autogenerated_1: Skipping Enable AMI deprecation...
==> amazon-ebs.autogenerated_1: Terminating the source AWS instance...
==> amazon-ebs.autogenerated_1: Cleaning up any extra volumes...
==> amazon-ebs.autogenerated_1: No volumes to clean up, skipping
==> amazon-ebs.autogenerated_1: Deleting temporary security group...
==> amazon-ebs.autogenerated_1: Deleting temporary keypair...

Build 'amazon-ebs.autogenerated_1' finished after 7 minutes 857 milliseconds.
```

If you want to run from github, commit a modification and the pipelines will start automatically and it will create the images. You can see the images in your AWS account, on EC2 console.

We can connect to our VM using RDP, enter the credentials used and the IP provided by the EC2 instance and see the application installed:
<img width="1512" alt="Screenshot 2024-04-18 at 19 54 10" src="https://github.com/biancapistea/webApi/assets/56589178/d3d1c5f4-47f7-4d8b-8b2a-1b36cc2f46b0">
<img width="1512" alt="Screenshot 2024-04-18 at 19 53 59" src="https://github.com/biancapistea/webApi/assets/56589178/fa15aca8-b000-4eb0-aab3-bcd746f1138f">

**The virtual machine - Step 3**
=============================

### Prerequisites: ###
1. Make sure you have terraform installed. If you are running on a macOS you can install it using these commands:
   brew tap hashicorp/tap
   brew install hashicorp/tap/terraform

**To manually create a virtual machine (VM) using a custom application image, you need to follow these steps:**

- Access AWS Console: Navigate to "EC2"
- Start the VM Creation Process: Click on the button to launch a new instance
- Select the Image: In the VM creation wizard, you'll be prompted to choose an image for your AMI. Select the option to use the custom image.
- Configure VM Settings: Configure the settings for your virtual machine, such as instance type, network settings, disk size, and security groups. Ensure that you select appropriate resources and settings based on your application requirements.
- Complete the Creation Process: Review the configuration settings to ensure everything is correct, then proceed to create the virtual machine instance.
- Access the VM: Once the VM is created, you can access it using SSH (for Linux-based VMs) or Remote Desktop Protocol (RDP) for Windows-based VMs. Use the appropriate credentials provided during the VM creation process to log in.

For provisioning the VM using terraform, you need to add this code:
```
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 4.16"
    }
  }

  required_version = ">= 1.2.0"
}

variable "aws_region" {
  type    = string
  default = "${env("AWS_REGION")}"
}

provider "aws" {
  region = var.aws_region
}

//Launch only one instance - provide the VM to the terraform
resource "aws_instance" "example" {
  ami           = "ami-0c8bcaea5abf84050"
  instance_type = "t2.micro"
  key_name      = "ami"
  subnet_id     = "subnet-00bd54cb02cc5c5c2"
  tags = {
    Name = "ExampleInstance"
  }
}
```

**Best Practices using Terraform:**
- **Consistency and reliability**: The Terraform state file serves as the source of truth for the deployed infrastructure. By following best practices, you ensure that the state accurately reflects the desired configuration, leading to consistent and reliable deployments.
- **Concurrency and collaboration**: In team environments where multiple developers are working simultaneously, proper state management prevents conflicts and ensures that changes are applied in a coordinated manner. This facilitates smooth collaboration and minimizes errors.
- **Reproducibility**: With a well-managed state file, you can reproduce infrastructure deployments reliably across different environments. This is essential for maintaining consistency between development, staging, and production environments.
- **Rollback and Disaster Recovery**: In the event of failures or the need to revert changes, a well-maintained state file simplifies the rollback process. By having a reliable record of previous states, you can quickly restore the infrastructure to a known good state.


**To ensure best practices for the Terraform state file, consider implementing the following:**
- Use a remote state backend to store the state file securely and enable collaboration.
- Implement state locking mechanisms to prevent concurrent modifications and ensure data integrity.
- Avoid storing sensitive information in the state file and use secure parameter stores for secret management.
- Backup the state file regularly to prevent data loss and enable recovery in case of accidental deletion or corruption.
- Continuous Integration/Continuous Deployment (CI/CD): Automate the deployment process using AWS CodePipeline or similar tools.
- Monitoring and Logging: Utilize AWS CloudWatch for monitoring application performance and logging.
- Security: Implement AWS Identity and Access Management (IAM) roles and policies for secure access control.
- Scalability: Leverage AWS Auto Scaling to manage application scaling based on demand.

**Load-balance multiple VM using Terraform.**
To load-balance multiple VMs using Terraform, we need to follow these steps:

- Defining AWS Load Balancer: Create an AWS Application Load Balancer (ALB) using the aws_lb resource in your Terraform configuration. This ALB distributes incoming traffic across multiple instances. (**apploadbalancer.tf**)
- Configuring Security Groups: Defined security groups for your instances and load balancer using the aws_security_group resource. These security groups control inbound and outbound traffic to your instances and load balancer. (**sg.tf**)
- Setting Up Target Groups: Defined AWS Target Groups using the aws_lb_target_group resource. These target groups are associated with your ALB and specify the instances that the ALB should route traffic to.  (**tg-attachment.tf**)
- Attaching Instances to Target Groups: Attached instances to the target groups using the aws_lb_target_group_attachment resource. This ensures that the ALB knows which instances are available to receive traffic. (**instance.tf**)
- Configuring Routing: Defined routing rules for your ALB using the aws_lb_listener resource. These rules specify how incoming traffic should be routed to the target groups based on conditions like the URL path or host header. (**routetable.tf**)
- VPC Configuration: Defined an AWS VPC using the aws_vpc resource. This VPC serves as the networking environment for your AWS resources, allowing you to isolate your resources logically. (**vpc.tf**)
- Subnet Configuration: Defined multiple AWS subnets within your VPC using the aws_subnet resource. These subnets are placed in different availability zones (AZs) to provide fault tolerance and high availability. By spreading your instances across multiple subnets and AZs, you ensure that your application remains available even if one AZ becomes unavailable. (**subnet.tf**)

Then, we need to run the following commands, in order:
- **terraform init** - This command initializes your Terraform working directory by downloading necessary plugins and modules defined in your configuration files. It's the first command you run when starting a new Terraform project or when adding new modules or providers to an existing project.
- **terraform plan** - This command generates an execution plan based on your Terraform configuration files. It compares the current state of your infrastructure with the desired state defined in your configuration files and identifies any changes that need to be made. Running terraform plan allows you to review the proposed changes before applying them.
- **terraform apply** - This command applies the changes defined in your Terraform configuration files to your infrastructure. It executes the plan generated by terraform plan and makes the necessary changes to bring your infrastructure to the desired state. You'll typically review the plan output from terraform plan before confirming and applying the changes with terraform apply.

Then, we can enter in our AWS account, EC2, to see the instances created:
<img width="1512" alt="Screenshot 2024-04-18 at 19 42 28" src="https://github.com/biancapistea/webApi/assets/56589178/acd09082-15e4-4f5c-a731-49c501b8599a">

See the load balancer:
<img width="1512" alt="Screenshot 2024-04-18 at 19 42 57" src="https://github.com/biancapistea/webApi/assets/56589178/88dc6d62-7e5a-4b27-ad2e-5f0d1ced1b04">

<img width="1512" alt="Screenshot 2024-04-18 at 19 43 19" src="https://github.com/biancapistea/webApi/assets/56589178/87610573-dc93-47af-a6e7-194ce2a9edb9">

See the VPC:
<img width="1512" alt="Screenshot 2024-04-18 at 19 44 04" src="https://github.com/biancapistea/webApi/assets/56589178/f17a5006-9d1d-4294-a74a-34764c7665fb">


#### Teoretically thinking how to implement blue-green strategy: ####

Terraform is used to define the infrastructure resources required for both the blue and green environments. This includes VPC, subnets, security groups, load balancer, target groups, and EC2 instances. The infrastructure is defined in a declarative manner, allowing for consistent and reproducible deployments.

 **For Blue Environment Setup**:
Let's say the existing Terraform configurations define the resources for the blue environment. These resources are deployed using Terraform to create the production-ready infrastructure.
The blue environment represents the current production state and serves live production traffic.

**For Green Environment Setup**:
The Terraform configurations from the blue environment are duplicated and modified to create resources for the green environment. These configurations mirror those of the blue environment to ensure consistency. The green environment is deployed using Terraform but remains inactive initially, serving as a standby environment ready to be switched into production.

**Deployment Process**:
Perform deployments to the green environment following the same process as deployments to the blue environment, using the commands terraform init, terraform plan and terraform apply.
Apply changes to the green environment using Terraform, which updates the infrastructure to reflect the desired state.
Conduct thorough testing and validation in the green environment to ensure that it behaves as expected and meets all functional requirements.

**Traffic Routing**:
Once the green environment is validated, traffic routing mechanisms are updated to direct production traffic to the green environment gradually. This can be achieved by updating the load balancer configuration or DNS settings to distribute traffic between the blue and green environments based on defined criteria.

**Monitoring**:
Utilize AWS CloudWatch and other monitoring tools to closely monitor both the blue and green environments. Both the blue and green environments needs to be closely monitored to track performance, availability, and other key metrics. Monitoring tools and dashboards are utilized to gain insights into the health and performance of the environments, enabling proactive detection and resolution of issues.

**Rollback procedure**:
We need to define a rollback procedure to revert traffic back to the blue environment in case of any issues or anomalies detected in the green environment. We can implement automated rollback mechanisms using Terraform or AWS services like AWS Lambda and AWS CloudFormation to switch traffic back to the blue environment seamlessly. Then, we need to conduct regular drills and simulations to test the rollback procedure and ensure its effectiveness in minimizing downtime and disruption to users.
